package com.example.scala.chapter08

/**
  * scala 中为了简化代码开发 , 当申明属性时 , 自动提供 setter/getter 方法
  * 当属性不加修饰符 , setter/getter 方法修饰符为 public
  * 当属性修饰符为 private 时 , setter/getter 方法修饰符为 private
  *
  */

/**
  * Scala封装的注意事项和细节
  * *
  * 因此我们如果只是对一个属性进行简单的set和get ，只要声明一下该属性(属性使用默认访问修饰符)
  * 不用写专门的getset，默认会创建，访问时，直接对象.变量。这样也是为了保持访问一致性 [案例]
  * *
  * 从形式上看 dog.food 直接访问属性，其实底层仍然是访问的方法,  看一下反编译的代码就明白
  * 有了上面的特性，目前很多新的框架，在进行反射时，也支持对属性的直接反射
  *
  */

/**
  * 第八章 面向对象高级部分
  *
  * Scala中静态的概念-伴生对象 , Scala语言是完全面向对象(万物皆对象)的语言，
  * 所以并没有静态的操作(即在Scala中没有静态的概念)。但是为了能够和Java语言交互(因为Java中有静态概念)，
  * 就产生了一种特殊的对象来模拟类对象，我们称之为类的伴生对象。
  * 这个类的所有静态内容都可以放置在它的伴生对象中声明和调用
  *
  */

/**
  * 伴生对象
  */
object Introduce {

}
